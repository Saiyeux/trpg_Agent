# TRPG状态管理文档
这个文档记录此项目的状态设计

## 用户输入分类
用户输入可以分为以下几类：
 1. **执行动作类**
    - 执行动作类首先要判断执行的是哪个动作，调用的函数，修改的状态。使用rag来确定。
    - 如果满足条件就执行，不满足条件要执行失败。
    - 执行结果对状态的修改反馈给玩家/同时将上一次的model response + user prompt + exec result合起来发给生文模型，让模型来一段描述结果的文字，反馈给玩家。
    - 这类动作更像是传统电子游戏或桌游中规则的执行，需要有严格的状态管理和执行流程。chatbot在其中扮演的角色一是识别，而是将其描绘出来。

 2. **查询类**
    - 查询并非查看背包或地图，而是向chatbot所扮演的Dungeon Master询问一些内容，比如，最近的村镇在哪？门后面有什么？周围环境/人物的情况等等。
    - 这类问题分类后先根据游戏状态做出一个难度设计，分为三档，一档是最简单的，可以直接根据用户提问作出回答与描述；第二档需要掷骰，如d20的10以内；第三档则需要d20的10以上。难度判断先随机，后续可以根据游戏状态生成一些标签类的属性来左右难度设置。
    - 如果检定失败了，就生成失败的结果返回给玩家。
 
 3. **探索与对话类**
    - 玩家说出和xx对话，去xx地点时，直接查询状态和上下文相关信息，给出回复即可。
    - TODO：非安全环境下探索的时候可能遇敌。但要不要战斗让玩家决定，例如是否避开或返回以及交谈或者威吓等。如果失败了再进入战斗

 4. **推理与想象类**
    - 玩家会根据已知内容（回复内容，状态等，都可以通过rag或函数调用来查看）进行一些奇特的操作，比如将火把丢在地毯上让地毯烧着，引起守卫的注意，或者模仿动物的叫声吓退怪物等。
    - 一旦归类为这个类型，就要做特殊处理
    - 首先要思考这个行为在当前状态下是否可行，其次要思考这样做的难度大小，让玩家过检定或者给出玩家一些有挑战的回复，来确认玩家是否执行。也即当玩家脱离出基本规则之外时，要根据当前的状态构建一个可行性和反馈的内容，来应对user prompt。如果可以的话使用一个思考类模型如qwen3:4b来思考，将思考的内容提炼一下反馈出来。
    - 当玩家确认这个动作能否执行/要不要执行后，该过检定的过检定，该更改状态的更改状态，然后回复玩家文本内容。
    - 这类问题是核心问题，也是AI代替人去进行DM主持的最有难度也是最出彩的部分。整体流程为：user prompt -> 意图识别 -> 归类为推理想象 -> 查询状态并给出可行性与结果 -> 生成文本 -> 用户执行 -> 下一步就回到了前三种类型里。总的来讲就是临场创造一个环境出来，同时要兼顾剧情世界观和游戏状态。

## 用户可执行的动作
 1. **攻击**
    - 普通攻击，区分近战和远程
    - 必须要有目标，而且是敌人类的目标。
    - 非战斗/非敌人 的目标，属于对话型应答，不进入function calling

 2. **使用技能**
    - 需要有目标或者范围
    - 需要满足释放条件（查询玩家状态/查询其他条件是否满足）
    - 我们现在已经有回合记录了，每回合玩家一次动作，敌人一次动作。但后续可以复杂化回合的内容。

 3. **使用物品**
    - 是否符合使用条件？人物状态，区域状态，战斗中能否使用等。
    - 区分是否为消耗品，消耗品要进行状态修改。
    - 非消耗品则将prompt转为对话，并查看是否要修改状态。

 4. **查看状态***
    - 查看角色的详情：基础属性（力量/敏捷/体质/智力/感知/魅力）；数值（生命值/法力值/其他（TODO））；状态（兴奋/魅惑/着火等等，有各种增/减益效果，后续将写入状态库中）；装备（从头到脚，后续设计装备格子）

    - 查看背包：金钱；物品（消耗品/箭支/投掷物/材料/其他）
    - 查看地图：已记录的地图，玩家的位置。要在每次prompt和模型输出的时候同步状态，按八方向记录地图地点。生成新的就记录在地图里，角色移动要修改并同步状态
    - 调查怪物的弱点（TODO）

 5. **休息**
    - 目前将休息做成一个框架中最简单的动作，后续会逐渐丰富。玩家可以在战斗以外随时休息。休息的结果会将时间推进到早上8点。

 6. **拾取**
    - 捡起地上/容器中/尸体等位置中的物品，修改背包状态。
 
 7. **盗窃与开锁**
    - 玩家在执行盗窃与开锁的时候，必须要查看环境是否允许或自身状态是否隐蔽。
    - 玩家在执行盗窃与开锁的时候，必须要有对应的能力标签，例如学技能书学会了，和某人学会了，或者职业赋予了类似的能力，如盗贼的巧手，法师的法师之手、敲击术等。
    - 玩家对人物的偷窃只有一次，只能拿一个物品（后续丰富选项）


## 状态管理流程

 1. 执行类
    - user prompt -> 意图识别 -> 检索函数 -> 执行并修改状态 -> 结果展示
      ｜
      -> 结果发送至文学类模型 -> 生成文学类文本并展示

 2. 创建类
 每次文学类生成模型或者玩家提出一个新的概念时，例如装备，技能，地图等等（这里只是举例，任何可以被写进状态的概念都包含）一些概念时，需要有一个功能（传统函数也好，深度学习也好）去记录这个概念，把这个概念写进状态中。
    
    示例一：
     - model response(你受到了魅惑，无法对魅惑你的对象攻击。) -> （模型在生成结果后既要显示给玩家，又要在后台进行状态同步）同步模型识别状态 -> 新生成了一些状态，例如技能（魅惑）与角色状态（被魅惑）-> 写入技能表和角色状态表 -> 修改角色状态
    
    示例二：
     - user prompt（我要躺在地上装死） -> 意图识别模型拿到prompt，识别意图并判别是否有新的状态（这里就要用到rag了） -> 意图区分后按其所在流程处理
        |
        -> 拿到新状态（人物状态：装死）后先创建状态，即写表 -> 这一步走完再让上述流程走至文学类文本处理，这样就有了新的数据库，可供rag查询并思考处理。
    
     - 我们的规则虽然有dnd的影子，但我不想把所有dnd的技能，职业都写进去，这样既有版权问题，也会把游戏框死在框架中。所以我们的mcp服务脚本，即function calling库中，不包含技能处理。而应该在每次模型回复的时候，比如告诉玩家学会了xx技能时，在写表时创建这个技能。所以技能在创建时应该有描述，计算规则（这些放在后面TODO，我们现在只要最小可行产品）所以写状态是个大工程，在游戏的过程中可能随时发生。
     - 这样一来，状态的导出和显示也需要做，例如用户想查询当前角色的技能，或者导出成txt，也需要有对应方法去执行。